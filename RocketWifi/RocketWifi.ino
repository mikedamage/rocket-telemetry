// Generated by Anthropic Claude

#include <WiFi.h>
#include <Wire.h>
#include <Adafruit_BMP280.h>
#include <AsyncTCP.h>
#include <LittleFS.h>

// Network configuration
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";
const char* serverIP = "192.168.1.100";  // Change to your server IP
const int serverPort = 8080;
const int localPort = 8081;  // Port for control server

// Command definitions
#define CMD_NOOP 0
#define CMD_START 1
#define CMD_STOP 2
#define CMD_REBOOT 3

// Sensor data structure
struct SensorReading {
  uint32_t timestamp;  // milliseconds since boot
  int16_t temperature; // Temperature * 100 (to preserve 2 decimal places)
  int16_t pressure;    // Pressure in Pa / 10 (to fit in 16-bit)
  int16_t altitude;    // Altitude in cm
};

// Buffer configuration
const int BUFFER_SIZE = 50;
SensorReading dataBuffer[BUFFER_SIZE];
int bufferIndex = 0;

// Timing
unsigned long lastReading = 0;
const unsigned long READING_INTERVAL = 20; // 20ms

// Objects
Adafruit_BMP280 bmp;
AsyncServer* controlServer;
AsyncClient* dataClient;

// File system
const char* csvFileName = "/telemetry.csv";
bool fileSystemReady = false;
bool csvLoggingEnabled = true;

// Status flags
bool sensorReady = false;
bool wifiConnected = false;
bool transmissionEnabled = true;
bool dataTransmissionInProgress = false;

void setup() {
  Serial.begin(115200);
  while (!Serial) delay(10);

  Serial.println("TinyPICO Rocket Telemetry System Starting...");

  // Initialize LittleFS
  if (LittleFS.begin()) {
    fileSystemReady = true;
    Serial.println("LittleFS mounted successfully");

    // Create CSV header if file doesn't exist
    if (!LittleFS.exists(csvFileName)) {
      File csvFile = LittleFS.open(csvFileName, "w");
      if (csvFile) {
        csvFile.println("timestamp,temperature,pressure,altitude");
        csvFile.close();
        Serial.println("CSV file created with header");
      }
    }

    // Check available space
    size_t totalBytes = LittleFS.totalBytes();
    size_t usedBytes = LittleFS.usedBytes();
    Serial.printf("Flash storage: %d/%d bytes used\n", usedBytes, totalBytes);

  } else {
    Serial.println("LittleFS mount failed");
    fileSystemReady = false;
  }

  // Initialize I2C (TinyPICO uses pins 22 and 21 by default)
  Wire.begin();

  // Initialize BMP280
  if (!bmp.begin(0x76)) {  // Try primary address first
    if (!bmp.begin(0x77)) {  // Try alternate address
      Serial.println("Could not find BMP280 sensor!");
      while (1) delay(10);
    }
  }

  // Configure BMP280 for high-speed readings
  bmp.setSampling(Adafruit_BMP280::MODE_NORMAL,     // Operating Mode
                  Adafruit_BMP280::SAMPLING_X2,     // Temp. oversampling
                  Adafruit_BMP280::SAMPLING_X16,    // Pressure oversampling
                  Adafruit_BMP280::FILTER_X16,      // Filtering
                  Adafruit_BMP280::STANDBY_MS_1);   // Standby time

  sensorReady = true;
  Serial.println("BMP280 initialized successfully");

  // Connect to WiFi
  connectWiFi();

  // Initialize AsyncTCP client
  dataClient = new AsyncClient();
  setupDataClientCallbacks();

  // Start control server
  controlServer = new AsyncServer(localPort);
  setupControlServer();
  controlServer->begin();
  Serial.println("Control server started on port " + String(localPort));

  Serial.println("System ready - starting data collection");
}

void loop() {
  // Take sensor readings every 20ms
  if (millis() - lastReading >= READING_INTERVAL) {
    takeSensorReading();
    lastReading = millis();
  }

  // Send buffer when full
  if (bufferIndex >= BUFFER_SIZE && transmissionEnabled && !dataTransmissionInProgress) {
    sendDataBuffer();
    logDataToCSV();  // Log to CSV at same frequency as transmission
  }

  // Reconnect WiFi if needed
  if (!WiFi.isConnected() && wifiConnected) {
    Serial.println("WiFi disconnected, attempting reconnection...");
    connectWiFi();
  }

  delay(1); // Small delay to prevent watchdog issues
}

void connectWiFi() {
  Serial.println("Connecting to WiFi: " + String(ssid));
  WiFi.begin(ssid, password);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    Serial.println();
    Serial.println("WiFi connected!");
    Serial.println("IP address: " + WiFi.localIP().toString());
  } else {
    wifiConnected = false;
    Serial.println();
    Serial.println("WiFi connection failed");
  }
}

void takeSensorReading() {
  if (!sensorReady) return;

  // Read sensor data
  float temp = bmp.readTemperature();
  float pressure = bmp.readPressure();
  float altitude = bmp.readAltitude(1013.25); // Sea level pressure in hPa

  // Convert to 16-bit integers to reduce payload size
  dataBuffer[bufferIndex].timestamp = millis();
  dataBuffer[bufferIndex].temperature = (int16_t)(temp * 100);        // Store as temp * 100
  dataBuffer[bufferIndex].pressure = (int16_t)(pressure / 10);        // Store as pressure / 10
  dataBuffer[bufferIndex].altitude = (int16_t)(altitude * 100);       // Store as altitude * 100 (cm)

  bufferIndex++;

  // Debug output every 25 readings (every 500ms)
  if (bufferIndex % 25 == 0) {
    Serial.printf("Reading %d: T=%.2fÂ°C, P=%.0fPa, A=%.2fm\n",
                  bufferIndex, temp, pressure, altitude);
  }
}

void setupDataClientCallbacks() {
  dataClient->onConnect([](void* arg, AsyncClient* client) {
    Serial.println("Connected to data server");

    // Send header with data count
    client->write((const char*)&bufferIndex, sizeof(int));

    // Send all readings
    for (int i = 0; i < bufferIndex; i++) {
      client->write((const char*)&dataBuffer[i], sizeof(SensorReading));
    }

    client->close();
  });

  dataClient->onDisconnect([](void* arg, AsyncClient* client) {
    Serial.println("Data sent successfully");
    bufferIndex = 0; // Reset buffer after successful transmission
    dataTransmissionInProgress = false;
  });

  dataClient->onError([](void* arg, AsyncClient* client, int error) {
    Serial.printf("Data client error: %d\n", error);
    dataTransmissionInProgress = false;
  });
}

void sendDataBuffer() {
  if (!wifiConnected || dataTransmissionInProgress) {
    return;
  }

  Serial.println("Sending data buffer (" + String(bufferIndex) + " readings)...");
  dataTransmissionInProgress = true;

  IPAddress serverAddr;
  if (serverAddr.fromString(serverIP)) {
    if (!dataClient->connect(serverAddr, serverPort)) {
      Serial.println("Failed to initiate connection to data server");
      dataTransmissionInProgress = false;
    }
  } else {
    Serial.println("Invalid server IP address");
    dataTransmissionInProgress = false;
  }
}

void logDataToCSV() {
  if (!fileSystemReady || !csvLoggingEnabled || bufferIndex == 0) {
    return;
  }

  // Check available space before writing
  size_t totalBytes = LittleFS.totalBytes();
  size_t usedBytes = LittleFS.usedBytes();
  size_t freeBytes = totalBytes - usedBytes;

  // Estimate space needed (roughly 50 bytes per reading)
  size_t estimatedBytes = bufferIndex * 50;

  if (freeBytes < estimatedBytes + 1000) { // Keep 1KB buffer
    Serial.println("Flash storage full - stopping CSV logging");
    csvLoggingEnabled = false;
    return;
  }

  File csvFile = LittleFS.open(csvFileName, "a");
  if (!csvFile) {
    Serial.println("Failed to open CSV file for writing");
    return;
  }

  // Write buffer data to CSV
  for (int i = 0; i < bufferIndex; i++) {
    csvFile.printf("%lu,%.2f,%.1f,%.2f\n",
                   dataBuffer[i].timestamp,
                   dataBuffer[i].temperature / 100.0,
                   dataBuffer[i].pressure * 10.0,
                   dataBuffer[i].altitude / 100.0);
  }

  csvFile.close();
  Serial.println("Data logged to CSV (" + String(bufferIndex) + " readings)");
}

void setupControlServer() {
  controlServer->onClient([](void* arg, AsyncClient* client) {
    Serial.println("Control client connected");

    client->onData([](void* arg, AsyncClient* client, void* data, size_t len) {
      if (len == 1) {
        uint8_t command = *((uint8_t*)data);
        handleControlCommand(command);
      }
    });

    client->onDisconnect([](void* arg, AsyncClient* client) {
      Serial.println("Control client disconnected");
    });

    client->onError([](void* arg, AsyncClient* client, int error) {
      Serial.printf("Control client error: %d\n", error);
    });
  }, nullptr);
}

void handleControlCommand(uint8_t command) {
  switch (command) {
    case CMD_NOOP:
      Serial.println("Command: NOOP");
      break;

    case CMD_START:
      Serial.println("Command: START transmission");
      transmissionEnabled = true;
      break;

    case CMD_STOP:
      Serial.println("Command: STOP transmission");
      transmissionEnabled = false;
      break;

    case CMD_REBOOT:
      Serial.println("Command: REBOOT");
      delay(100);
      ESP.restart();
      break;

    default:
      Serial.printf("Unknown command: %d\n", command);
      break;
  }
}
