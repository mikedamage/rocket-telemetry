// Generated by Anthropic Claude

#include <Arduino.h>
#include <WiFi.h>
#include <Wire.h>
#include <Adafruit_BME280.h>
#include <Adafruit_Sensor.h>
#include <WiFiUdp.h>
#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include <AsyncJson.h>
#include <LittleFS.h>
#include <Preferences.h>
#include <NimBLEDevice.h>
#include <NimBLEBeacon.h>
#include <TinyPICO.h>
#include <esp_wifi.h>

// Compile-time checks for required WiFi credentials
#ifndef WIFI_SSID
#error "WIFI_SSID must be defined. Set environment variable before building: export WIFI_SSID=\"YourSSID\""
#endif

#ifndef WIFI_PSK
#error "WIFI_PSK must be defined. Set environment variable before building: export WIFI_PSK=\"YourPassword\""
#endif

// Forward declarations
void wifiConnectionLost(WiFiEvent_t event);
void wifiGotIP(WiFiEvent_t event, WiFiEventInfo_t info);
void wifiSoftAPStarted(WiFiEvent_t event);
void wifiGotClient(WiFiEvent_t event, WiFiEventInfo_t info);
size_t littlefsFreeSpace();
void provisionPreferences();
void loadConfiguration();
void saveConfiguration();
void calibrateAltimeter();
void connectWiFi();
bool createFlightLog();
bool createCsvLog();
void setupHTTPServer();
void takeSensorReading();
void checkTelemetryTimeout();
void initializeBLE();
void activateBLEBeacon();
void sendDataBuffer();
bool canWriteFlightLog();

#define CONFIG_VERSION 3
#define DEFAULT_READING_INTERVAL 20
#define DEFAULT_SERVER_IP "192.168.4.1"
#define DEFAULT_REFERENCE_PRESSURE 1013.25
#define BASELINE_PRESSURE_READINGS 20

// Default configuration values
const char *DEFAULT_SSID = "RocketTelemetry";
const char *DEFAULT_PASSWORD = "telemetry123";
const uint16_t DEFAULT_SERVER_PORT = 4210;
const uint32_t DEFAULT_TELEMETRY_TIMEOUT = 120000;  // 2 minutes of telemetry

// Network configuration (will be loaded from preferences)
String configSSID;
String configPassword;
unsigned long readingInterval;
float_t groundReferencePressure;
uint32_t telemetryTimeout;
String serverIP = "192.168.4.1";  // Ground station WiFi-LR AP IP address
int serverPort = 4210;
const int localPort = 80;  // Port for HTTP API server

// iBeacon UUID for rocket identification (generate your own!)
#define BEACON_UUID "79daf75a-182c-4cc9-ad65-640ad1fd7b3b"
#define BEACON_MAJOR 1
#define BEACON_MINOR 1

NimBLEAdvertising *beaconAdvertising = nullptr;

// Sensor data structure
const int BUFFER_SIZE = 10;
int bufferIndex = 0;
struct SensorReading {
  unsigned long timestamp;  // milliseconds since boot
  int16_t temperature;      // Temperature * 100 (to preserve 2 decimal places)
  uint16_t pressure;        // Pressure in hPa (Pa / 100) (to fit in 16-bit)
  uint16_t altitude;        // Altitude in cm (meters * 100)
  uint16_t humidity;        // Humidity in percent (rh * 100)
};

SensorReading dataBuffer[BUFFER_SIZE];

// Buffer configuration
// CircularBuffer<SensorReading, BUFFER_SIZE> ringBuffer;

// Timing
unsigned long lastReading = 0;
unsigned long currentTime = 0;
unsigned long telemetryStartTime = 0;

// Landing detection variables
bool timeoutElapsed = false;
bool forceActivateBeacon = false;

// Objects
static WiFiUDP telemetrySender;
IPAddress serverAddress;
Adafruit_BME280 bme;
AsyncWebServer server(localPort);
Preferences preferences;
TinyPICO tp = TinyPICO();

// File system
const char *logFileName = "/flight_log.msgpack";
const char *csvFileName = "/telemetry.csv";
bool fileSystemReady = false;
bool csvLoggingEnabled = true;

// Status flags
bool sensorReady = false;
volatile bool wifiConnected = false;
volatile bool transmissionEnabled = false;
bool dataTransmissionInProgress = false;
bool beaconActive = false;
volatile bool enableSoftAP = false;
bool wifiCallbacksSet = false;
volatile bool wifiAttemptReconnect = true;
bool forceRecalibrateAltimeter = false;

NimBLEBeacon beacon;

void wifiConnectionLost(WiFiEvent_t event) {
  Serial.println(F("WiFi connection lost!"));
  wifiConnected = false;
  wifiAttemptReconnect = !transmissionEnabled;  // don't block onboard flight data recording waiting for a wifi connection
  enableSoftAP = transmissionEnabled || timeoutElapsed;
}

void wifiGotIP(WiFiEvent_t event, WiFiEventInfo_t info) {
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(IPAddress(info.got_ip.ip_info.ip.addr));
  Serial.print(F("RSSI: "));
  Serial.println(WiFi.RSSI());
  wifiConnected = true;
  enableSoftAP = false;
}

void wifiSoftAPStarted(WiFiEvent_t event) {
  Serial.println(F("WiFi SoftAP started"));
  Serial.print(F("SoftAP IP address: "));
  Serial.println(WiFi.softAPIP());
  wifiConnected = true;
}

void wifiGotClient(WiFiEvent_t event, WiFiEventInfo_t info) {
  Serial.println(F("Client connected to SoftAP"));
}

void setup() {
  Serial.begin(115200);
  while (!Serial)
    delay(10);

  Serial.println(F("TinyPICO Rocket Telemetry System Starting..."));

  // Load configuration from preferences
  loadConfiguration();

  // Initialize LittleFS
  if (LittleFS.begin(true)) {
    fileSystemReady = true;
    Serial.println(F("LittleFS mounted successfully"));

    // Create CSV header if file doesn't exist
    createCsvLog();

    // Check available space
    size_t totalBytes = LittleFS.totalBytes();
    size_t usedBytes = LittleFS.usedBytes();
    size_t freeBytes = littlefsFreeSpace();
    Serial.printf("Flash storage: %d/%d bytes used\n", usedBytes, totalBytes);
    Serial.printf("Free flash storage: %d bytes\n", freeBytes);
  } else {
    Serial.println(F("LittleFS mount failed"));
    fileSystemReady = false;
  }

  // Initialize I2C (TinyPICO uses pins 22 and 21 by default)
  Wire.begin();

  // Initialize BME280
  if (bme.begin(0x76)) {  // Try primary address first
    // Configure BME280 for high-speed readings
    bme.setSampling(Adafruit_BME280::MODE_NORMAL,      // Operating Mode
                    Adafruit_BME280::SAMPLING_X2,      // Temp. oversampling
                    Adafruit_BME280::SAMPLING_X8,      // Pressure oversampling
                    Adafruit_BME280::SAMPLING_X1,      // Humidity oversampling
                    Adafruit_BME280::FILTER_X8,        // Filtering
                    Adafruit_BME280::STANDBY_MS_0_5);  // Standby time

    sensorReady = true;

    // Take several pressure readings to establish a ground reference
    calibrateAltimeter();
  } else {
    Serial.println(F("Could not find BME280 sensor!"));
    Serial.println(F("Proceeding with wifi and HTTP API setup, but no readings will be gathered"));
  }

  Serial.print("Battery voltage: ");
  Serial.println(tp.GetBatteryVoltage());
  Serial.print("Is charging? ");
  Serial.println(tp.IsChargingBattery());

  // Connect to WiFi
  connectWiFi();

  // Initialize AsyncTCP client
  bool validServerAddress = serverAddress.fromString(serverIP);
  if (!validServerAddress) {
    Serial.printf(F("Invalid server address: %s\n"), serverIP);
  } else {
    Serial.printf(F("Forwarding telemetry to: %s:%d\n"), serverAddress.toString(), serverPort);
  }

  // Setup HTTP REST API server
  setupHTTPServer();
  server.begin();
  Serial.print(F("HTTP API server started on port "));
  Serial.println(String(localPort));

  // Initialize BLE (but don't start beacon yet)
  initializeBLE();

  Serial.println(F("System ready"));
}

void loop() {
  currentTime = millis();
  checkTelemetryTimeout();

  if (sensorReady && forceRecalibrateAltimeter) {
    calibrateAltimeter();
  }

  if (!timeoutElapsed && transmissionEnabled) {
    // Normal flight operations

    // Take sensor readings at configured interval
    if (currentTime - lastReading >= readingInterval) {
      takeSensorReading();
    }

    // Send buffer when full
    if (bufferIndex >= BUFFER_SIZE && transmissionEnabled && !dataTransmissionInProgress) {
      dataTransmissionInProgress = true;
      sendDataBuffer();
      bufferIndex = 0;
      dataTransmissionInProgress = false;
    }

    // Reconnect WiFi if needed, but don't block flight data recording
    if (!wifiConnected && (wifiAttemptReconnect || enableSoftAP)) {
      connectWiFi();
    }
  }

  if ((timeoutElapsed || forceActivateBeacon) && !beaconActive) {
    activateBLEBeacon();
  }

  delay(1);  // Small delay to prevent watchdog issues
}

size_t littlefsFreeSpace() {
  size_t totalBytes = LittleFS.totalBytes();
  size_t usedBytes = LittleFS.usedBytes();
  return totalBytes - usedBytes;
}

void provisionPreferences() {
  preferences.begin("rocket-config", false);
  preferences.clear();
  preferences.putUShort("config_version", CONFIG_VERSION);
  preferences.putString("ssid", DEFAULT_SSID);
  preferences.putString("password", DEFAULT_PASSWORD);
  preferences.putULong("interval", DEFAULT_READING_INTERVAL);
  preferences.putFloat("ground_reference_pressure", DEFAULT_REFERENCE_PRESSURE);
  preferences.putString("server_ip", DEFAULT_SERVER_IP);
  preferences.putUShort("server_port", DEFAULT_SERVER_PORT);
  preferences.putULong("telemetry_timeout", DEFAULT_TELEMETRY_TIMEOUT);
  preferences.end();
}

void loadConfiguration() {
  preferences.begin("rocket-config", true);

  if (preferences.isKey("config_version") == false || preferences.getUShort("config_version") != CONFIG_VERSION) {
    preferences.end();
    provisionPreferences();
    preferences.begin("rocket-config", true);
  }

  // Load WiFi configuration
  configSSID = preferences.getString("ssid", DEFAULT_SSID);
  configPassword = preferences.getString("password", DEFAULT_PASSWORD);
  readingInterval = preferences.getULong("interval", DEFAULT_READING_INTERVAL);
  serverIP = preferences.getString("server_ip", DEFAULT_SERVER_IP);
  serverPort = preferences.getUShort("server_port", DEFAULT_SERVER_PORT);
  telemetryTimeout = preferences.getULong("telemetry_timeout", DEFAULT_TELEMETRY_TIMEOUT);

  Serial.println(F("Configuration loaded:"));
  Serial.print(F("SSID: "));
  Serial.println(configSSID);
  Serial.printf(F("Reading interval: %lu ms\n"), readingInterval);
  Serial.printf(F("Server address: %s:%d\n"), serverIP, serverPort);
  Serial.printf(F("Telemetry timeout: %lu seconds\n"), telemetryTimeout / (uint32_t)1000);

  preferences.end();
}

void saveConfiguration() {
  preferences.begin("rocket-config", false);

  preferences.putString("ssid", configSSID);
  preferences.putString("password", configPassword);
  preferences.putULong("interval", readingInterval);
  preferences.putString("server_ip", serverIP);
  preferences.putUShort("server_port", serverPort);
  preferences.putULong("telemetry_timeout", telemetryTimeout);

  preferences.end();
  Serial.println(F("Configuration saved to preferences"));
}

void calibrateAltimeter() {
  Serial.println(F("Calibrating altimeter to ground reference air pressure."));
  Serial.printf(F("Averaging %d readings over %.1f seconds"), BASELINE_PRESSURE_READINGS, BASELINE_PRESSURE_READINGS * 0.5);

  float_t baselinePressureReadings[BASELINE_PRESSURE_READINGS];
  uint8_t baselineReadingIndex = 0;

  while (baselineReadingIndex < BASELINE_PRESSURE_READINGS) {
    baselinePressureReadings[baselineReadingIndex] = bme.readPressure() / 100.0;
    baselineReadingIndex++;
    Serial.print(".");
    delay(500);
  }

  float_t baselinePressureSum = 0.0;

  for (uint8_t i = 0; i < BASELINE_PRESSURE_READINGS; i++) {
    baselinePressureSum += baselinePressureReadings[i];
  }
  groundReferencePressure = (baselinePressureSum / (float_t)BASELINE_PRESSURE_READINGS);

  Serial.printf(F("\nGround reference pressure set to %.4f\n"), groundReferencePressure);
  Serial.println(F("BME280 initialized successfully"));
  forceRecalibrateAltimeter = false;
}

void connectWiFi() {
  if (!wifiCallbacksSet) {
    WiFi.onEvent(wifiConnectionLost, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_DISCONNECTED);
    WiFi.onEvent(wifiGotIP, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_GOT_IP);
    WiFi.onEvent(wifiSoftAPStarted, WiFiEvent_t::ARDUINO_EVENT_WIFI_AP_START);
    WiFi.onEvent(wifiGotClient, WiFiEvent_t::ARDUINO_EVENT_WIFI_AP_STACONNECTED);
    Serial.println(F("WiFi event callbacks set"));
    wifiCallbacksSet = true;
  }

  if (WiFi.status() == WL_CONNECTED) {
    return;
  }

  if (!wifiConnected && enableSoftAP) {
    WiFi.disconnect(true);
    WiFi.mode(WIFI_AP);
    WiFi.softAP("RocketWifi-AP");
  } else {
    Serial.print(F("Connecting to WiFi: "));
    Serial.println(WIFI_SSID);

    // Enable Long Range mode for extended WiFi range
    // esp_wifi_set_protocol(WIFI_IF_STA, WIFI_PROTOCOL_LR);
    WiFi.mode(WIFI_STA);
    WiFi.enableLongRange(true);
    Serial.println(F("Long Range WiFi mode enabled"));

    Serial.println("Scanning for networks...");
    byte numNetworks = WiFi.scanNetworks();
    Serial.printf("Found %d SSIDs:\n", numNetworks);

    for (int i = 0; i < numNetworks; i++) {
      Serial.print("  - ");
      Serial.print(WiFi.SSID(i));
      Serial.print(" (RSSI: ");
      Serial.print(WiFi.RSSI(i));
      Serial.println(")");
      delay(10);
    }
    Serial.println();

    WiFi.begin(WIFI_SSID, WIFI_PSK);

    Serial.printf("Connecting to wifi network SSID %s\n", WIFI_SSID);


    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 20) {
      delay(500);
      attempts++;
    }

    if (WiFi.status() != WL_CONNECTED) {
      wifiConnected = false;
      enableSoftAP = true;
      Serial.println();
      Serial.println(F("WiFi connection failed. Enabling hotspot."));
      connectWiFi();  // Retry connection
    }
  }
}

bool createFlightLog() {
  if (LittleFS.exists(logFileName)) {
    Serial.println(F("Flight log already exists, not creating new one"));
    return false;
  }
  File file = LittleFS.open(logFileName, "w");
  if (!file) {
    return false;
  }
  return true;
}

bool createCsvLog() {
  if (LittleFS.exists(csvFileName)) {
    Serial.println(F("CSV log already exists, not creating new one"));
    return false;
  }
  File file = LittleFS.open(csvFileName, "w");
  if (file) {
    file.println(F("timestamp,temperature,pressure,altitude"));
    file.close();
  }
  return true;
}

void setupHTTPServer() {
  // GET /telemetry.csv - download onboard telemetry log from local flash filesystem
  server.serveStatic("/telemetry.csv", LittleFS, "/telemetry.csv");

  // DELETE /telemetry.csv - truncate onboard telemetry log from local flash filesystem
  server.on("/telemetry.csv", HTTP_DELETE, [](AsyncWebServerRequest *request) {
    AsyncJsonResponse *response = new AsyncJsonResponse();
    JsonVariant responseRoot = response->getRoot();

    if (LittleFS.remove("/telemetry.csv")) {
      LittleFS.open("/telemetry.csv", "w");
      responseRoot["success"] = true;
      responseRoot["message"] = "Telemetry log truncated";
    } else {
      responseRoot["success"] = false;
      responseRoot["message"] = "Failed to delete telemetry log";
    }

    response->setLength();
    response->setCode(responseRoot["success"] ? 200 : 500);
    response->setContentType("application/json");
    request->send(response);
  });

  // GET /status - Get system status
  server.on("/status", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;

    doc["uptime"] = millis();
    doc["wifi_connected"] = wifiConnected;
    doc["wifi_rssi"] = WiFi.RSSI();
    doc["sensor_ready"] = sensorReady;
    doc["transmission_enabled"] = transmissionEnabled;
    doc["landing_detected"] = timeoutElapsed;
    doc["beacon_active"] = beaconActive;
    doc["buffer_count"] = bufferIndex;
    doc["buffer_size"] = BUFFER_SIZE;
    doc["free_heap"] = ESP.getFreeHeap();
    doc["free_flash_storage"] = littlefsFreeSpace();
    doc["reading_interval"] = readingInterval;
    doc["ground_reference_pressure"] = groundReferencePressure;
    doc["battery_voltage"] = tp.GetBatteryVoltage();
    doc["battery_charging"] = tp.IsChargingBattery();

    if (sensorReady) {
      float temp = bme.readTemperature();
      float pressure = bme.readPressure();
      float altitude = bme.readAltitude(groundReferencePressure);
      float humidity = bme.readHumidity();

      doc["current_temperature"] = temp;
      doc["current_pressure"] = pressure / 100.0;
      doc["current_altitude"] = altitude;
      doc["current_humidity"] = humidity;
    }

    String response;
    serializeJson(doc, response);
    request->send(200, "application/json", response);
  });

  // POST /command - Send control commands
  AsyncCallbackJsonWebHandler *commandPostHandler = new AsyncCallbackJsonWebHandler("/command", [](AsyncWebServerRequest *request, JsonVariant &json) {
    AsyncJsonResponse *response = new AsyncJsonResponse();
    JsonVariant responseRoot = response->getRoot();
    JsonObject body = json.as<JsonObject>();

    String command = body["command"];
    bool success = true;
    String message = "OK";

    if (command == "start") {
      transmissionEnabled = true;
      telemetryStartTime = millis();
      message = "Transmission enabled";
    } else if (command == "stop") {
      transmissionEnabled = false;
      message = "Transmission disabled";
    } else if (command == "reset") {
      bufferIndex = 0;
      message = "Buffer reset";
    } else if (command == "reboot") {
      message = "Rebooting...";
      responseRoot["success"] = true;
      responseRoot["message"] = message;
      response->setLength();
      response->setCode(200);
      response->setContentType("application/json");
      request->send(response);
      delay(100);
      ESP.restart();
      return;
    } else if (command == "start_beacon") {
      if (!beaconActive) {
        forceActivateBeacon = true;
        message = "Activating BLE beacon";
      } else {
        success = false;
        message = "BLE beacon already active";
      }
    } else if (command == "recalibrate_altimeter") {
      forceRecalibrateAltimeter = true;
      message = "Recalibrating altimeter";
      success = true;
    } else {
      success = false;
      message = "Unknown command";
    }

    responseRoot["success"] = success;
    responseRoot["message"] = message;

    response->setLength();
    response->setCode(success ? 200 : 400);
    response->setContentType("application/json");
    request->send(response);
  });

  server.addHandler(commandPostHandler);

  // GET /config - Get current configuration
  server.on("/config", HTTP_GET, [](AsyncWebServerRequest *request) {
    AsyncJsonResponse *response = new AsyncJsonResponse();
    JsonVariant responseRoot = response->getRoot();

    responseRoot["ssid"] = configSSID;
    responseRoot["password"] = "[HIDDEN]";  // Don't expose password
    responseRoot["reading_interval"] = readingInterval;
    responseRoot["ground_reference_pressure"] = groundReferencePressure;
    responseRoot["server_ip"] = serverIP;
    responseRoot["server_port"] = serverPort;
    responseRoot["telemetry_timeout"] = telemetryTimeout;

    response->setLength();
    response->setCode(200);
    response->setContentType("application/json");
    request->send(response);
  });

  AsyncCallbackJsonWebHandler *configPutHandler = new AsyncCallbackJsonWebHandler("/config", [](AsyncWebServerRequest *request, JsonVariant &json) {
    AsyncJsonResponse *response = new AsyncJsonResponse();
    JsonVariant responseRoot = response->getRoot();

    Serial.println(F("updating config:"));
    serializeJson(json, Serial);
    Serial.println();

    JsonObject body = json.as<JsonObject>();
    bool configChanged = false;
    String message = "Configuration updated";

    // Update WiFi SSID
    if (body.containsKey("ssid")) {
      String newSSID = body["ssid"];
      if (newSSID != configSSID) {
        configSSID = newSSID;
        configChanged = true;
      }
    }

    // Update WiFi password
    if (body.containsKey("password")) {
      String newPassword = body["password"];
      if (newPassword != configPassword) {
        configPassword = newPassword;
        configChanged = true;
      }
    }

    // Update reading interval
    if (body.containsKey("reading_interval")) {
      unsigned long newInterval = body["reading_interval"];
      if (newInterval >= 10 && newInterval <= 10000) {  // Limit between 10ms and 10s
        readingInterval = newInterval;
        Serial.printf(F("Reading interval updated to: %lu ms\n"), readingInterval);
      } else {
        message = "Invalid reading interval (must be 10-10000 ms)";
      }
    }

    if (body.containsKey("ground_reference_pressure")) {
      float_t newReferencePressure = body["ground_reference_pressure"];
      if (newReferencePressure != groundReferencePressure) {
        groundReferencePressure = newReferencePressure;
        configChanged = true;
      }
    }

    if (body.containsKey("server_ip")) {
      String newServerIP = body["server_ip"];
      if (newServerIP != serverIP) {
        serverIP = newServerIP;
        configChanged = true;
      }
    }

    if (body.containsKey("server_port")) {
      int newServerPort = body["server_port"];
      if (newServerPort != serverPort) {
        serverPort = newServerPort;
        configChanged = true;
      }
    }

    if (body.containsKey("telemetry_timeout")) {
      uint32_t newTelemetryTimeout = body["telemetry_timeout"];
      if (newTelemetryTimeout != telemetryTimeout) {
        telemetryTimeout = newTelemetryTimeout;
        configChanged = true;
      }
    }

    // Save configuration
    saveConfiguration();

    // If WiFi config changed, note that restart may be needed
    if (configChanged) {
      message += " (WiFi restart may be required)";
    }

    responseRoot["success"] = true;
    responseRoot["message"] = message;
    responseRoot["config_changed"] = configChanged;

    response->setContentType("application/json");
    response->setLength();
    request->send(response);
  });
  configPutHandler->setMethod(HTTP_PUT | HTTP_POST);


  // PUT /config - Update configuration
  server.addHandler(configPutHandler);
}

void takeSensorReading() {
  if (!sensorReady || timeoutElapsed)
    return;

  // Read sensor data
  float temp = bme.readTemperature() * 100.0F;
  float pressure = bme.readPressure() / 100.0F;                         // hPa
  float altitude = bme.readAltitude(groundReferencePressure) * 100.0F;  // relative to configured ground reference in hPa
  float humidity = bme.readHumidity() * 100.0F;

  lastReading = currentTime;

  // Convert to 16-bit integers to reduce payload size
  SensorReading reading;
  reading.timestamp = lastReading;
  reading.temperature = (int16_t)(temp);
  reading.pressure = (uint16_t)(pressure);
  reading.altitude = (uint16_t)(altitude);
  reading.humidity = (uint16_t)(humidity);
  dataBuffer[bufferIndex] = reading;
  // ringBuffer.push(reading);

  bufferIndex++;

  // Debug output every 25 readings
  if (bufferIndex % 25 == 0) {
    Serial.printf(F("Reading %d: T=%.2fÂ°C, P=%.0fPa, A=%.2fm, RH=%.2f%% (interval: %lums)\n"),
                  bufferIndex, temp, pressure, altitude, humidity, readingInterval);
  }
}

void checkTelemetryTimeout() {
  if (transmissionEnabled && currentTime - telemetryStartTime >= telemetryTimeout) {
    Serial.println(F("Telemetry timeout elapsed. Stopping transmission."));
    timeoutElapsed = true;
    transmissionEnabled = false;
  }
}

void initializeBLE() {
  Serial.println(F("Initializing BLE..."));
  NimBLEDevice::init("RocketBeacon");
  beacon.setMajor(BEACON_MAJOR);
  beacon.setMinor(BEACON_MINOR);
  beacon.setSignalPower(0xD3);
  beacon.setProximityUUID(NimBLEUUID(BEACON_UUID));
  // beacon.setManufacturerId(0x004C); // Apple Inc. iBeacon
  NimBLEAddress macAddress = NimBLEDevice::getAddress();

  NimBLEAdvertisementData beaconAdvertisementData;
  beaconAdvertisementData.setFlags(0x04);  // BR_EDR_NOT_SUPPORTED
  beaconAdvertisementData.setName("RocketBeacon");
  beaconAdvertisementData.addTxPower();
  beaconAdvertisementData.setManufacturerData(beacon.getData());

  beaconAdvertising = NimBLEDevice::getAdvertising();
  beaconAdvertising->setAdvertisingInterval(160);  // 100ms
  beaconAdvertising->setAdvertisementData(beaconAdvertisementData);
  Serial.printf(F("BLE beacon initialized. MAC Address: %s\n"), macAddress.toString().c_str());
}

void activateBLEBeacon() {
  Serial.println(F("Activating BLE beacon for rocket recovery..."));
  beaconAdvertising->start();
  beaconActive = true;
  Serial.println(F("BLE beacon active - rocket can now be located!"));
}

void sendDataBuffer() {
  File csvFile;
  File flightLog;

  Serial.printf("Sending data buffer and writing to local log (%d readings)...\n", bufferIndex);

  dataTransmissionInProgress = true;
  JsonDocument jsonPayload;
  JsonArray readings = jsonPayload["readings"].to<JsonArray>();

  bool willWriteToLog = canWriteFlightLog();

  if (willWriteToLog) {
    csvFile = LittleFS.open(csvFileName, "a");
    if (!csvFile) {
      willWriteToLog = false;
      Serial.println(F("Failed to open CSV file for writing"));
    }
  }

  // Send all readings
  for (int i = 0; i < bufferIndex; i++) {
    JsonObject reading = readings.add<JsonObject>();
    reading["timestamp"] = dataBuffer[i].timestamp;
    reading["temperature"] = dataBuffer[i].temperature;
    reading["pressure"] = dataBuffer[i].pressure;
    reading["altitude"] = dataBuffer[i].altitude;
    reading["humidity"] = dataBuffer[i].humidity;

    // record to local CSV flight log
    if (willWriteToLog) {
      char csvLine[100] = "";
      int bytesWritten = snprintf(
        csvLine,
        sizeof(csvLine),
        "%lu,%d,%u,%u,%u\n",
        dataBuffer[i].timestamp,
        dataBuffer[i].temperature,
        dataBuffer[i].pressure,
        dataBuffer[i].altitude,
        dataBuffer[i].humidity);

      if (bytesWritten > sizeof(csvLine)) {
        Serial.printf(F("Warning: csvLine truncated. Attempted length: %d"), bytesWritten);
      }
      csvFile.print(csvLine);
    }
  }

  if (willWriteToLog) {
    csvFile.close();
    Serial.println(F("CSV log updated"));
  }

  if (!wifiConnected) {
    dataTransmissionInProgress = false;
    return;
  }

  // send batch as UDP packet to telemetry server
  // const byte *payload = reinterpret_cast<const byte *>(csvLine);
  const uint32_t txStart = micros();
  telemetrySender.beginPacket(serverAddress, serverPort);
  // telemetrySender.write(payload, strlen(csvLine));
  size_t udpBytes = serializeMsgPack(jsonPayload, telemetrySender);
  // size_t udpBytes = serializeJson(jsonPayload, telemetrySender);
  telemetrySender.endPacket();
  const uint32_t txEnd = micros();
  const uint32_t txDuration = txEnd - txStart;
  float txRate = udpBytes / (txDuration / 1000.0);  // kilobytes/s
  dataTransmissionInProgress = false;

  Serial.printf(F("telemetry batch (%u bytes) sent to UDP endpoint in %lu ms\n"), udpBytes, txEnd - txStart);
  Serial.printf(F("Tx rate: %.2f kb/s\n"), txRate);
}

bool canWriteFlightLog() {
  if (!fileSystemReady || !csvLoggingEnabled) {
    return false;
  }

  size_t totalBytes = LittleFS.totalBytes();
  size_t usedBytes = LittleFS.usedBytes();
  size_t freeBytes = totalBytes - usedBytes;

  // Estimate space needed (roughly 50 bytes per reading)
  size_t estimatedBytes = bufferIndex * 50;

  if (freeBytes < estimatedBytes + 1000) {  // Keep 1KB buffer
    Serial.println(F("Flash storage full - stopping CSV logging"));
    csvLoggingEnabled = false;
    return false;
  }

  return true;
}
